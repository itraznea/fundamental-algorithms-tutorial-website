<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="icon" type="image/x-icon" href="images/favicon.png">
    <title>Algoritmi Fundamentali</title>
</head>
<body>
    <header>
        <div class="container grid">
            <div class="logo flex">
                <a href=""><img src="images/logo_white.png" alt="logo"></a>
                <h1><a href="index.html">Algoritmi Fundamentali</a></h1>
            </div>
            <div class="mobile-menu flex">
                <ul>
                    <li><a href="index.html">Acasă</a></li>
                    <li><a href="algoritmi_elementari.html">Elementari</a></li>
                    <li><a href="algoritmi_de_sortare.html">Sortare</a></li>
                    <li><a href="algoritmi_de_cautare.html">Căutare</a></li>
                    <li><a href="complexitatea_algoritmilor.html">Complexitate</a></li>
                </ul>
            </div>
            <nav class="small-nav">
                <div class="ham-menu-button">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </nav>
            <nav class="big-nav">
                <ul class="flex">
                    <li><a href="index.html">Acasă</a></li>
                    <li><a href="algoritmi_elementari.html">Elementari</a></li>
                    <li><a href="algoritmi_de_sortare.html">Sortare</a></li>
                    <li><a href="algoritmi_de_cautare.html">Căutare</a></li>
                    <li><a href="complexitatea_algoritmilor.html">Complexitate</a></li>
                </ul>
            </nav>
        </div>

    </header>
    <main>
        <div class="container">
            <div class="alg-page alg-sort">
                <h1>Algoritmi de sortare</h1>
                <i class="img"></i>
            </div>
            <div class="alg-articles">
                <article>
                    <h2>Metoda bulelor (bubble sort)</h2>
                    <p>
                        Algoritmul constă în parcurgerea tabloului <b>A</b> de mai multe ori, până când devine ordonat. 
                        La fiecare pas se compară două elemente alăturate și se interschimbă daca este necesar.<br>
                        Controlul acţiunii repetitive este dat de variabila booleană <b>schimbat</b>, care la fiecare 
                        reluare a algoritmului primeşte valoarea iniţială <b>false</b>, și se schimbă în <b>true</b> dacă s-a 
                        efectuat o interschimbare de două elemente alăturate.<br>
                        Metoda bulelor nu este cea mai performantă modalitate de a ordona un şir cu multe elemente, 
                        dar în cazul şirurilor „aproape ordonate” poate deveni mai eficientă decât alte metode.<br>
                    </p>
                    <pre><code>
void bubbleSort(int n, int a[]){
    bool schimbat;
    do{
        schimbat = false;
        int i;
        for(i = 0; i < n-1; i++){
            if (a[i] > a[i+1]){
                int aux = a[i];
                a[i] = a[i+1];
                a[i+1] = aux;
                schimbat = true;
            }
        }
    } while(schimbat);
}
                    </code></pre>

                    <h2>Sortarea prin selecție directă (selection sort)</h2>
                    <p>
                        Sortarea prin selecție directă (sau sortarea prin selecție) 
                        este un algoritm simplu de sortare care funcționează prin împărțirea unui 
                        tablou în două părți: o parte sortată și o parte nesortată.<br>
                        Algoritmul selectează repetat cel mai mic (sau cel mai mare) element din partea 
                        nesortată și îl mută la sfârșitul părții sortate.<br>
                        De exemplu, în caz de ordonare crescătoare, pornind de la primul element se 
                        caută valoarea minimă din tablou. Aceasta se aşează pe prima poziţie printr-o 
                        interschimbare între elementul de pe prima poziţie şi elementul minim. Apoi, 
                        se reia algoritmul, pornind de la a doua poziţie.<br>
                    </p>
                    <pre><code>
void selectionSort(int n, int a[]){
    int aux, minIndex, i, j;
    for (i = 0; i < n-1; i++){
        minIndex = i;
        for (j = i+1; j < n; j++){
            if (a[minIndex] > a[j]){
                minIndex = j;
            }
        }

        if(minIndex != i){
            aux = a[i];
            a[i] = a[minIndex];
            a[minIndex] = aux;
        }
    }
}
                    </code></pre>

                    <h2>Sortarea prin inserţie (insertion sort)</h2>
                    <p>
                        Este un algoritm eficient pentru sortarea unui număr mic de obiecte.
                        <br>
                        Sortarea prin inserţie funcţionează în acelaşi fel în care mulţi oameni 
                        sortează un pachet de cărţi de joc.
                        <br>
                        Se începe cu pachetul aşezat pe masa cu faţa în jos şi cu mâna stânga goala. 
                        Apoi, luăm câte o carte de pe masă şi o inseram în poziţia corectă în mâna stângă. 
                        Pentru a găsi poziţia corectă pentru o carte dată, o comparăm cu fiecare dintre 
                        cărţile aflate deja în mâna stângă, de la dreapta la stânga (sau de la stânga la dreapta).
                        <br>
                    </p>
                    <pre><code>
void insertionSort(int n, int a[]){
    int i, j, aux;
    for (i = 1; i < n; i++){
        aux = a[i];
        j = i - 1;
        while(j >= 0 && a[j] > aux){
            a[j+1] = a[j];
            j--;
        }
        a[j+1] = aux;
    }
}
                    </code></pre>

                    <h2>Sortarea rapidă (quick sort)</h2>
                    <p>
                        Sortarea rapidă este un algoritm de sortare eficient și popular, care funcționează 
                        prin alegerea unui element pivot și a rearanjării elementelor din jurul lui. 
                        Iată cum funcționează:<br>
                        <ul>
                            <li>
                                <b>-se alege un element din lista de sortat, care va servi ca punct de referință 
                                pentru rearanjarea elementelor. Acest element se numește pivot;</b>
                            </li>
                            <li>
                                <b>-se parcurge lista, iar fiecare element se compară cu pivotul. 
                                Lista se împarte în două subliste: una care conține elementele mai mici 
                                decât pivotul și alta care conține elementele mai mari decât pivotul. 
                                La final pivotul se află la locul său corect în listă. Acest pas se numeste partajare;</b>
                            </li>
                            <li>
                                <b>-procesul de partajare se aplică recursiv pentru fiecare sublistă, până când toate sublistele au fost sortate;</b>
                            </li>
                            <li>
                                <b>-când lista are o lungime de 0 sau 1, se consideră deja sortat și nu se mai 
                                apelează recursiv algoritmul, iar în final se combină rezultatele sortării 
                                sublistelor pentru a obține lista sortată finală.</b>
                            </li>
                        </ul>
                    </p>
                    <p>
                        Sortarea rapidă este un algoritm de sortare care, pentru un sir de n elemente, 
                        are un timp de execuţie <b>O(n^2)</b> în cazul cel mai defavorabil.<br>
                        În ciuda acestei comportări proaste, în cazul cel mai defavorabil, algoritmul 
                        de sortare rapidă este deseori cea mai bună soluţie practică, deoarece are o comportare 
                        medie remarcabilă. Timpul său mediu de execuţie este <b>O(n log n)</b>.
                    </p>
                    <pre><code>
int partition(int arr[], int st, int end){
    int pivot, pIndex;

    pivot = arr[end];
    pIndex = st;

    for (int i = st; i < end; i++){
        if (arr[i] < pivot){
            swap(arr[i], arr[pIndex]);
            pIndex++;
        }
    }
    swap(arr[end], arr[pIndex]);
    return pIndex;
}
    
void quickSort(int arr[], int st, int end){
    if (st < end){
        int pivIndex;
        pivIndex = partition(arr, st, end);
        quickSort(arr, st, pivIndex-1);
        quickSort(arr, pivIndex+1, end);
    }
}
                    </code></pre>

                    <h2>Sortarea prin interclasare (merge sort)</h2>
                    <p>
                        Sortarea prin interclasare este un algoritm de sortare eficient, care utilizează 
                        o abordare recursivă și divide şi stăpâneşte pentru a sorta elementele unui sir.
                        <br>
                        Pentru metoda de sortare prin interclasare principiul desparte şi stăpâneşte 
                        poate fi privit astfel:
                        <br>
                    </p>
                    <p>
                        <b>Desparte:</b> dacă lista conține o singură sau nicio elementă, atunci lista 
                        este considerată deja sortată. În caz contrar, lista este împărțită recursiv în 
                        două părți aproximativ egale până când fiecare parte conține o singură sau nicio elementă.
                        <br>
                        <b>Stăpâneşte:</b> fiecare parte este sortată recursiv prin aplicarea merge sort. 
                        Dacă o parte conține o singură sau nicio elementă, atunci partea 
                        este considerată deja sortată.
                        <br>
                        <b>Combină:</b> elementele sortate ale ambelor părți sunt combinate într-o 
                        singură listă sortată. Acest pas este denumit "merge" și este realizat prin iterarea 
                        simultană a ambelor liste sortate și compararea elementelor corespunzătoare. Cel mai mic 
                        element dintre cele două este selectat și adăugat la lista rezultat. Această procedură 
                        continuă până când una dintre liste este complet iterată. Dacă rămân 
                        elemente în lista neiterată, atunci ele sunt adăugate la lista rezultat în 
                        ordinea lor originală.
                    </p>
                    <p>
                        Acest algoritm are o complexitate temporală de <b>O(n log n)</b> în cel mai rău și mediu caz, 
                        ceea ce îl face potrivit pentru sortarea listelor lungi.
                    </p>
                    <pre><code>
void mergeSort(int a[], int st, int dr) {
    if (st >= dr)
        return;

    int mij = (st + dr) / 2;
    mergeSort(a, st, mij);
    mergeSort(a, mij+1, dr);

    int tmp[dr - st + 1];
    int k = 0;
    int i = st, j = mij+1;

    while(i <= mij && j <= dr){
        if (a[i] < a[j])
            tmp[k++] = a[i++];
        else
            tmp[k++] = a[j++];
    }

    while(i <= mij)
        tmp[k++] = a[i++];

    while (j <= dr)
        tmp[k++] = a[j++];

    for (i = st, k = 0; i <= dr; i++, k++)
        a[i] = tmp[k];
}
                    </code></pre>
                </article>
            </div>
        </div>
    </main>
    <footer>
        <div class="container grid">
            <div class="logo flex">
                <a href=""><img src="images/logo_white.png" alt="logo"></a>
                <h4><a href="index.html">Algoritmi Fundamentali</a></h4>
            </div>
            <div class="socials flex">
                <a href="https://facebook.com" target="_blank" rel="nofollow"><img src="images/fb.svg" alt=""></a>
                <a href="https://x.com" target="_blank" rel="nofollow"><img src="images/x.svg" alt=""></a>
                <a href="https://instagram.com" target="_blank" rel="nofollow"><img src="images/insta.svg" alt=""></a>
                <a href="https://youtube.com" target="_blank" rel="nofollow"><img src="images/yt.svg" alt=""></a>
            </div>
        </div>
    </footer>
    <script src="script.js"></script>
</body>
</html>