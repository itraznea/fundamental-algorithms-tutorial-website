<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="icon" type="image/x-icon" href="images/favicon.png">
    <title>Algoritmi Fundamentali</title>
</head>
<body>
    <header>
        <div class="container grid">
            <div class="logo flex">
                <a href=""><img src="images/logo_white.png" alt="logo"></a>
                <h1><a href="index.html">Algoritmi Fundamentali</a></h1>
            </div>
            <div class="mobile-menu flex">
                <ul>
                    <li><a href="index.html">Acasă</a></li>
                    <li><a href="algoritmi_elementari.html">Elementari</a></li>
                    <li><a href="algoritmi_de_sortare.html">Sortare</a></li>
                    <li><a href="algoritmi_de_cautare.html">Căutare</a></li>
                    <li><a href="complexitatea_algoritmilor.html">Complexitate</a></li>
                </ul>
            </div>
            <nav class="small-nav">
                <div class="ham-menu-button">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </nav>
            <nav class="big-nav">
                <ul class="flex">
                    <li><a href="index.html">Acasă</a></li>
                    <li><a href="algoritmi_elementari.html">Elementari</a></li>
                    <li><a href="algoritmi_de_sortare.html">Sortare</a></li>
                    <li><a href="algoritmi_de_cautare.html">Căutare</a></li>
                    <li><a href="complexitatea_algoritmilor.html">Complexitate</a></li>
                </ul>
            </nav>
        </div>

    </header>
    <main>
        <div class="container">
            <div class="alg-page alg-elementary">
                <h1>Algoritmi elementari</h1>
                <i class="img"></i>
            </div>
            <div class="alg-articles">
                <article>
                    <h2>Separarea cifrelor unui număr</h2>
                    <p>
                        Se va folosi rezultatul din matematică conform căruia restul împărţirii la 10 al unui
                        număr întreg pozitiv îl reprezintă ultima cifră a numărului (cea mai puţin semnificativă),
                        iar câtul împărţirii la 10, numărul fără ultima cifră. Repetând această operaţie cât timp
                        numărul mai are cifre de separat, obţinem la fiecare pas o cifră a numărului, care poate
                        fi prelucrată, de fiecare dată câtul obţinut devenind deîmpărţit. În algoritm, marcarea
                        încheierii separării cifrelor se face când numărul dat devine 0, deci nu mai sunt cifre de
                        separat.
                    </p>
                    <pre><code>
int n;
cin &gt;&gt; n;
while (n){
    cout &lt;&lt; n % 10 &lt;&lt; " ";
    n = n / 10;
}
                    </code></pre>

                    <h2>Determinarea divizorilor proprii ai unui număr natural dat</h2>
                    <p>
                        De exemplu, dacă n=50, divizorii proprii sunt: 2, 5, 10, 25;<br>
                        dacă n=45, divizorii proprii sunt: 3, 5, 9, 15;<br>
                        dacă n=32, divizorii proprii sunt: 2, 4, 8, 16.<br>
                    </p>
                    <p><b>Complexitate radical O(√n) </b>- cea mai eficienta in cazul de fata</p>
                    <pre><code>
int n;
cin >> n;
for (int d = 2; d*d &lt;= n; d++ ) {
    if (n % d == 0)
        cout &lt;&lt; d &lt;&lt; " ";
    if (d != n / d)
        cout &lt;&lt; n/d;
}
                    </code></pre>
                    <p><b>Complexitate liniara O(n)</b></p>
                    <pre><code>
int n;
cin &gt;&gt; n;
for (int d = 2; d &lt; n/2; d++)
    if (n % d == 0)
        cout &lt;&lt; d &lt;&lt; " ";
                    </code></pre>
                    <h2>Testul de număr prim</h2>
                    <p>Matematica ne spune că un număr
                        este prim dacă are doar doi divizori,
                        pe 1 şi numărul însuşi, deci când nu
                        are divizori proprii. Sunt mai multe
                        modalităţi de a verifica dacă un
                        număr dat este prim sau nu. Noi o
                        vom folosi pe cea conform căreia
                        dacă numărul nu are divizori proprii
                        atunci este prim, în caz contrar, dacă
                        are cel puţin un divizor propriu,
                        atunci numărul nu este prim.</p>
                    <pre><code>
bool isPrime (int n){
    if (n < 2)
        return false;
    
    bool prim = true;
    
    for (int d = 2; d*d <= n; d++){
        if (n%d == 0){
            prim = false;
            break;
        }
    }
    return prim;
}
                    </code></pre>

                    <h2>Determinarea celui mai mare divizor comun a două numere naturale</h2>
                    <p><strong>Algoritmul lui Euclid</strong>- cel mai eficient in cazul de fata</p>
                    <p>
                        Să presupunem că avem două numere naturale a şi b,
                        pentru care trebuie să aflăm cel mai mare divizor
                        comun(cmmdc). Se reţine în variabila r restul împărţirii
                        lui a la b. Variabila a ia valoarea variabilei b iar b ia
                        valoarea restului obţinut în urma împărţirii lui a la b.
                        Aceste operaţii se execută cât timp b este diferit de
                        0. Cel mai mare divizor comun va fi variabila a.
                    </p>
                    <pre><code>
int a, b;
cin >> a >> b;
while (b){
    int r = a % b;
    a = b;
    b = r;
}
cout << a;
                    </code></pre>
                    <p><strong>Algoritmul scăderilor repetate</strong></p>
                    <p>
                        Algoritmul este următorul: cât timp cele două numere a
                        şi b sunt diferite între ele, se scade din numărul mai
                        mare numărul mai mic. În momentul în care cele două
                        numere devin egale, cmmdc se află în oricare din cele
                        două numere a sau b.
                    </p>
                    <pre><code>
int a, b;
while (a != b){
    if (a > b)
        a = a - b;
    else
        b = b - a;
}
cout << a;
                    </code></pre>

                    <h2>Descompunerea în factori primi a unui număr natural</h2>
                    <p>
                        Vom trata mai intai factorul 2 separat pentru optimizare.
                        Dacă n este par se imparte repetat cu 2 până când devine impar.
                        Acest lucru va elimina toți factorii de 2 din n înainte de a începe căutarea altor factori primi.

                        Se porneşte de la urmatorul factor prim posibil, 3;
                        cât timp numărul dat este diferit de 1, se execută
                        operaţiile:
                        dacă factorul îl divide pe n îl afişăm
                        cât timp numărul se împarte exact la un factor prim
                        se execută împărţirea, se prelucrează factorul şi câtul devine deîmpărţit
                        se trece apoi la următorul factor prim.
                    </p>
                    <pre><code>
int n, d = 3, p = 0;
cin >> n;

// Tratarea factorului 2 pentru optimizare
while (n % 2 == 0) {
    p++;
    n = n / 2;
}
if (p)
    cout << "2^" << p << " ";

// Tratarea factorilor impari
while (n > 1 && d*d <= n){
    p = 0;
    while (n % d == 0){
        p++;
        n = n / d;
    }
    if (p)
        cout << d << "^" << p << " ";
    d+=2;
}
                    </code></pre>

                    <h2>Determinarea valorii minime/maxime dintr-un şir de numere</h2>
                    <p><strong>Determinarea valorii maxime</strong></p>
                    <p>
                        Se presupune că primul număr citit este maximul. Se citesc
                        apoi, pe rând, numerele şi la fiecare pas se compară numărul
                        citit cu maximul existent. Dacă numărul citit este mai mare
                        decât maximul, se înlocuieşte maximul.
                    </p>
                    <pre><code>
int n, a, max;
cin >> n >> a;
max = a;
for (int i = 2; i <= n; i++){
    cin >> a;
    if (max < a)
        max = a;
}
cout << max;
                    </code></pre>
                    <p><strong>Determinarea valorii minime</strong></p>
                    <p>
                        Se presupune că primul număr citit este minimul. Se citesc
                        apoi, pe rând, numerele şi la fiecare pas se compară numărul
                        citit cu minimul existent. Dacă numărul citit este mai mic
                        decât minimul, se înlocuieşte minimul.
                    </p>
                    <pre><code>
int n, a, min;
cin >> n >> a;
min = a;
for (int i = 2; i <= n; i++){
    cin >> a;
    if (min > a)
        min = a;
}
cout << min;
                    </code></pre>

                    <h2>Interschimbarea valorilor a două variabile</h2>
                    <p><strong>Utilizarea unei variabile temporare</strong></p>
                    <p>Pentru a înțelege mai bine soluția vom face o analogie cu o altă problemă. <br>
                        Să presupunem că avem două pahare <b>a</b> și <b>b</b>, paharul <b>a</b> plin cu apă și paharul <b>b</b> plin cu lapte. 
                        Să presupunem că vrem să schimbăm conținutul paharelor astfel încât paharul <b>a</b> să conțină în final lapte și paharul <b>b</b> să conțină în final apă. Este
                        clar că nu putem rezolva problema fără a ne folosi de un al treilea pahar, gol, să îi spunem <b>aux</b>, de la auxiliar.<br>
                        Pentru a face interschimbul putem vărsa paharul <b>a</b> în paharul <b>aux</b>, apoi paharul <b>b</b> în paharul <b>a</b> și
                        în final paharul <b>aux</b> în paharul <b>b</b>. </p>
                    <pre><code>
void swap(int& a, int& b){
    int aux = a;
    a = b;
    b = aux;
}
                    </code></pre>
                    <p><strong>Fara utilizarea unei variabile temporare</strong></p>
                    <pre><code>
void swap (int& a, int& b){
    a = a + b;
    b = a - b;
    a = a - b;
}
                    </code></pre>

                    <h2>Suma cifrelor unui număr natural</h2>
                    <pre><code>
int sum(int n){
    int sum = 0;
    while (n){
        sum = sum + n % 10;
        n = n/10;
    }
    return sum;
}
                    </code></pre>

                    <h2>Aflarea primei cifre a unui număr natural</h2>
                    <pre><code>
int primaCifra (int n){
    while (n > 9)
        n = n/10;
    return n;
}
                    </code></pre>

                    <h2>Determinarea oglinditului unui număr natural</h2>
                    <pre><code>
int oglindit(int n){
    int ogl = 0;
    while (n){
        ogl = ogl * 10 + n%10;
        n = n/10;
    }
    return ogl;
}
                    </code></pre>

                    <h2>Palindrom (număr)</h2>
                    <pre><code>
bool palindromNr (unsigned int n) {
    unsigned int r = 0;
    while (n > r){
        r = r * 10 + p % 10;
        p = p / 10;
    }

    if (p == r || r / 10 == p)
        return true;
    else
        return false;
}
                    </code></pre>

                    <h2>Palindrom (string)</h2>
                    <pre><code>
int palindromStr (string& text) {
    int i = 0, j = text.length()-1;
    bool palindrom = true;
    while (i < j){
        if (text[i] != text[j]){
            palindrom = false;
            break;
        }
        i++;
        j--;
    }
    return palindrom;
}
                    </code></pre>

                    <h2>Cel mai mic multiplu comun (cmmmc)</h2>
                    <pre><code>
int cmmmc (int a, int b){
    int p, r;
    p = a * b
    while (b){
        r = a % b;
        a = b;
        b = r;
    }
    return p / a;
}
                    </code></pre>

                    <h2>Numărul de elemente divizibile cu k intr-un interval</h2>
                    <p><strong>Numar de elemente incluzand capetele</strong></p>
                    <pre><code>
int elemDivInterval (int a, int b){
    return b/k - (a-1)/k;
}
                    </code></pre>
                    <p><strong>Numar de elemente excluzand capetele</strong></p>
                    <pre><code>
int elemDivInterval (int a, int b){
    return (b-1)/k - a/k;
}
                    </code></pre>

                    <h2>Cifra de control</h2>
                    <p><strong>Varianta intuitiva</strong></p>
                    <pre><code>
int cifraControl (int n){
    int s ;
    while (n > 9){
        s = 0;
        while (n > 0){
            s = s + n%10;
            n = n/10;
        }
        n = s;
    }
    return n;
}
                    </code></pre>
                    <p><strong>Metoda trunchierii</strong></p>
                    <pre><code>
int metodaTrunchierii (int n){
    while (n > 9)
        n = n%10 + n/10;
    return n;
}
                    </code></pre>
                    <p><strong>Metoda verificarii divizibilitatii cu 9 (complexitate constanta)</strong></p>
                    <pre><code>
int divNoua (int n){
    if (n % 9 == 0)
        return 9;
    else
        return n % 9;
}
                    </code></pre>

                    <h2>Fibonacci</h2>
                    <p><strong>Metoda recursiva</strong></p>
                    <pre><code>
unsigned int fRec (unsigned int n){
    if (n < 2)
        return 1;
    else
        return fRec(n-1) + fRec(n-2);
}
                    </code></pre>
                    <p><strong>Metoda liniara</strong></p>
                    <pre><code>
unsigned int fLin(unsigned int n){
    if (n <= 2)
        return 1;

    unsigned int a = 1, b = 1, c, i;
    for (i = 3; i<= n; i++){
        c = a+b;
        a = b;
        b = c;
    }

    return c;
}
                    </code></pre>
                </article>
            </div>
        </div>
    </main>
    <footer>
        <div class="container grid">
            <div class="logo flex">
                <a href=""><img src="images/logo_white.png" alt="logo"></a>
                <h4><a href="index.html">Algoritmi Fundamentali</a></h4>
            </div>
            <div class="socials flex">
                <a href="https://facebook.com" target="_blank" rel="nofollow"><img src="images/fb.svg" alt=""></a>
                <a href="https://x.com" target="_blank" rel="nofollow"><img src="images/x.svg" alt=""></a>
                <a href="https://instagram.com" target="_blank" rel="nofollow"><img src="images/insta.svg" alt=""></a>
                <a href="https://youtube.com" target="_blank" rel="nofollow"><img src="images/yt.svg" alt=""></a>
            </div>
        </div>
    </footer>
    <script src="script.js"></script>
</body>
</html>